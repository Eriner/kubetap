{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kubetap Documentation Kubetap is a open source CNI-agnostic project by that automates the process of proxying Kubernetes Services. VIDEO : Kubetap introduction by Matt Hamilton Use Cases Security Testing When assessing web applications, it is common to use BurpSuite, MITMproxy, Zap, or other intercepting proxy to capture and modify HTTP requests on a security tester\u2019s machine. These requests are intercepted and modified on the tester\u2019s local machine prior to being sent to the remote server. While this paradigm allowed testers to capture and modify all traffic that the testers themselves create, testers can not see traffic destined for the target server that originates from other Services. The lack of visibility of intranet traffic that does not originate from a tester\u2019s machine can hamper a tester\u2019s ability to competently review complex systems and environments. For environments that use Kubernetes, Kubetap is altering the status quo. Kubetap allows testers to select a target Service and intercept all traffic that is destined for that Service, regardless of where the requests originate. The transparency and visibility afforded by Kubetap allows testers to better understand and exercise the Service without the prohibitively (expensive) time cost of configuring and deploying a proxy manually. Microservices deep in a technology stack that were once inaccessible to testers can now be proxied with ease. Developer debugging When an application or microservice is exhibiting unintended behavior, developers must debug the application through a debugger, printf statements, or static code analysis. This is often because infrastructure architecture looks something like this: What happens when the bug is only exhibited when deployed to staging and production, and not in a local development environment? [xkcd-979] xkcd While there are tools like Telepresence that allow developers to move containers running in a cluster on to their local machines for debugging, this is a heavy-handed approach and not practical in many situations. Often developers just need to visually inspect Service inputs, such as JSON objects, that originate from other microservices. Kubetap allows developers to deploy MITMproxy in front of a Service, enabling visibility for all incoming HTTP traffic to that Service. With this, developers can inspect and debug a Service without unnecessary printf debugging code-pushes View the Quick start guide to begin using kubetap","title":"Introduction"},{"location":"#kubetap-documentation","text":"Kubetap is a open source CNI-agnostic project by that automates the process of proxying Kubernetes Services. VIDEO : Kubetap introduction by Matt Hamilton","title":"Kubetap Documentation"},{"location":"#use-cases","text":"","title":"Use Cases"},{"location":"#security-testing","text":"When assessing web applications, it is common to use BurpSuite, MITMproxy, Zap, or other intercepting proxy to capture and modify HTTP requests on a security tester\u2019s machine. These requests are intercepted and modified on the tester\u2019s local machine prior to being sent to the remote server. While this paradigm allowed testers to capture and modify all traffic that the testers themselves create, testers can not see traffic destined for the target server that originates from other Services. The lack of visibility of intranet traffic that does not originate from a tester\u2019s machine can hamper a tester\u2019s ability to competently review complex systems and environments. For environments that use Kubernetes, Kubetap is altering the status quo. Kubetap allows testers to select a target Service and intercept all traffic that is destined for that Service, regardless of where the requests originate. The transparency and visibility afforded by Kubetap allows testers to better understand and exercise the Service without the prohibitively (expensive) time cost of configuring and deploying a proxy manually. Microservices deep in a technology stack that were once inaccessible to testers can now be proxied with ease.","title":"Security Testing"},{"location":"#developer-debugging","text":"When an application or microservice is exhibiting unintended behavior, developers must debug the application through a debugger, printf statements, or static code analysis. This is often because infrastructure architecture looks something like this: What happens when the bug is only exhibited when deployed to staging and production, and not in a local development environment? [xkcd-979] xkcd While there are tools like Telepresence that allow developers to move containers running in a cluster on to their local machines for debugging, this is a heavy-handed approach and not practical in many situations. Often developers just need to visually inspect Service inputs, such as JSON objects, that originate from other microservices. Kubetap allows developers to deploy MITMproxy in front of a Service, enabling visibility for all incoming HTTP traffic to that Service. With this, developers can inspect and debug a Service without unnecessary printf debugging code-pushes View the Quick start guide to begin using kubetap","title":"Developer debugging"},{"location":"FAQ/","text":"FAQ Errors build kubetap Go toolchain not new enough Kubetap requires Go version 1.14 or later. You can check the current Go version by running: $ go version go version go1.14.2 darwin/amd64 Errors running kubetap Why can't I run the tap command after installing from source? If you get an error like this: $ kubectl tap --help Error: unknown command \"tap\" for \"kubectl\" Did you mean this? top cp And if you can't execute the standalone binary in a shell, as in: kubectl-tap ...then it is likely that your ${GOPATH}/bin directory is not in your ${PATH} . Try adding the following line to your .bashrc or .zshrc : export PATH = \" ${ GOPATH } /bin: ${ PATH } \" The Mac OS Binary doesn't run Mac binaries require notarization. It is recommended to use Homebrew to install Kubetap on Mac, or to build from source.","title":"FAQ"},{"location":"FAQ/#faq","text":"","title":"FAQ"},{"location":"FAQ/#errors-build-kubetap","text":"","title":"Errors build kubetap"},{"location":"FAQ/#go-toolchain-not-new-enough","text":"Kubetap requires Go version 1.14 or later. You can check the current Go version by running: $ go version go version go1.14.2 darwin/amd64","title":"Go toolchain not new enough"},{"location":"FAQ/#errors-running-kubetap","text":"","title":"Errors running kubetap"},{"location":"FAQ/#why-cant-i-run-the-tap-command-after-installing-from-source","text":"If you get an error like this: $ kubectl tap --help Error: unknown command \"tap\" for \"kubectl\" Did you mean this? top cp And if you can't execute the standalone binary in a shell, as in: kubectl-tap ...then it is likely that your ${GOPATH}/bin directory is not in your ${PATH} . Try adding the following line to your .bashrc or .zshrc : export PATH = \" ${ GOPATH } /bin: ${ PATH } \"","title":"Why can't I run the tap command after installing from source?"},{"location":"FAQ/#the-mac-os-binary-doesnt-run","text":"Mac binaries require notarization. It is recommended to use Homebrew to install Kubetap on Mac, or to build from source.","title":"The Mac OS Binary doesn't run"},{"location":"about/","text":"About Kubetap was built by Matt Hamilton, aka Eriner , at Soluble.ai . Kubetap There is a blog post on the Soluble website that details the development motivation and implementation of Kubetap. Soluble Soluble makes Kubernetes security simple, providing strong identity, access, certificates, policy, secrets, and more. Using a pay-for-what-you-use pricing model, Soluble offers services built on accepted third party and open source tools, managed by its SaaS-based API control plane. Founded in 2019 by industry veterans with experience running security and operations at large organizations, Soluble is backed by Dell Technologies Capital. You can click here to learn more about Soluble and how we're operationalizing Kubernetes security .","title":"About"},{"location":"about/#about","text":"Kubetap was built by Matt Hamilton, aka Eriner , at Soluble.ai .","title":"About"},{"location":"about/#kubetap","text":"There is a blog post on the Soluble website that details the development motivation and implementation of Kubetap.","title":"Kubetap"},{"location":"about/#soluble","text":"Soluble makes Kubernetes security simple, providing strong identity, access, certificates, policy, secrets, and more. Using a pay-for-what-you-use pricing model, Soluble offers services built on accepted third party and open source tools, managed by its SaaS-based API control plane. Founded in 2019 by industry veterans with experience running security and operations at large organizations, Soluble is backed by Dell Technologies Capital. You can click here to learn more about Soluble and how we're operationalizing Kubernetes security .","title":"Soluble"},{"location":"acknowledgements/","text":"Acknowledgements Mitmproxy We give our thanks to the author and contributors of mitmproxy, in particular @cortesi and @mhils . Without their excellent work on mitmproxy, kubetap would not exist. @omrikiei & @vfreex While we have not (yet) elected to integrate ktunnel or create our own implementation, we are grateful that omrikiei has taken on the task of creating a feature implementation until there is a native implementation for kubernetes/kubernetes#20227 . We are also grateful to @vfreex for his PR to resolve #20227 that remains unmerged . Early kubetap testers We are grateful to the early kubetap testers who helped to ensure that kubetap works in a variety of environments and configurations. Their feedback was crucial and highly appreciated.","title":"Acknowledgements"},{"location":"acknowledgements/#acknowledgements","text":"","title":"Acknowledgements"},{"location":"acknowledgements/#mitmproxy","text":"We give our thanks to the author and contributors of mitmproxy, in particular @cortesi and @mhils . Without their excellent work on mitmproxy, kubetap would not exist.","title":"Mitmproxy"},{"location":"acknowledgements/#omrikiei-vfreex","text":"While we have not (yet) elected to integrate ktunnel or create our own implementation, we are grateful that omrikiei has taken on the task of creating a feature implementation until there is a native implementation for kubernetes/kubernetes#20227 . We are also grateful to @vfreex for his PR to resolve #20227 that remains unmerged .","title":"@omrikiei &amp; @vfreex"},{"location":"acknowledgements/#early-kubetap-testers","text":"We are grateful to the early kubetap testers who helped to ensure that kubetap works in a variety of environments and configurations. Their feedback was crucial and highly appreciated.","title":"Early kubetap testers"},{"location":"getting_started/installation/","text":"Installation From Source The recommended installation method is to clone the repository and run: $ go generate $ go install ./cmd/kubectl-tap Homebrew Soluble provides a homebrew formula repository to use brew to build from source. brew tap soluble-ai/homebrew-kubetap brew install kubetap From Binary Release Binary releases for Mac, Windows, and Linux of varying architectures are available from the Releases page . With Krew Kubetap can be installed with krew : kubectl krew install tap","title":"Installation"},{"location":"getting_started/installation/#installation","text":"","title":"Installation"},{"location":"getting_started/installation/#from-source","text":"The recommended installation method is to clone the repository and run: $ go generate $ go install ./cmd/kubectl-tap","title":"From Source"},{"location":"getting_started/installation/#homebrew","text":"Soluble provides a homebrew formula repository to use brew to build from source. brew tap soluble-ai/homebrew-kubetap brew install kubetap","title":"Homebrew"},{"location":"getting_started/installation/#from-binary-release","text":"Binary releases for Mac, Windows, and Linux of varying architectures are available from the Releases page .","title":"From Binary Release"},{"location":"getting_started/installation/#with-krew","text":"Kubetap can be installed with krew : kubectl krew install tap","title":"With Krew"},{"location":"getting_started/quick-start/","text":"Quick Start Selecting a target After you have successfully installed kubetap , find a Service you'd like to tap. In this example, we use ArgoCD as the target. $ kubectl get svc -n argocd NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE argocd-dex-server ClusterIP 10 .43.152.9 <none> 5556 /TCP,5557/TCP 5d20h argocd-metrics ClusterIP 10 .43.44.33 <none> 8082 /TCP 5d20h argocd-redis ClusterIP 10 .43.209.196 <none> 6379 /TCP 5d20h argocd-repo-server ClusterIP 10 .43.192.56 <none> 8081 /TCP,8084/TCP 5d20h argocd-server-metrics ClusterIP 10 .43.220.237 <none> 8083 /TCP 5d20h argocd-server ClusterIP 10 .43.118.109 <none> 80 /TCP,443/TCP 5d20h Tapping the service The proxy container (MITMProxy by default) runs as a sidecar, keeping network traffic within the cluster and incurring a lessened performance penalty when proxying the traffic. For this example, we target the HTTPS argocd-server service: $ kubectl tap on -n argocd -p 443 --https argocd-server --port-forward Establishing port-forward tunnels to service... Port-Forwards: mitmproxy - http://127.0.0.1:2244 argocd-server - http://127.0.0.1:4000 Connecting to the proxy As shown above, you can now navigate to http://127.0.0.1:2244 to access the proxy. Note that you can also use the --browser flag with tap on to automatically open the printed URLs in the default browser. --browser implies --port-forward . http://127.0.0.1:2244 Listing active taps All active taps can be listed using the following command, which can be constrained to a specific namespace with -n : $ kubectl tap list Tapped Namespace/Service: argocd/argocd-server Untapping the service Once we are finished, we can remove the proxy and revert our tap by turning it off: $ kubectl tap off -n argocd argocd-server Untapped Service \"argocd-server\"","title":"Quick Start"},{"location":"getting_started/quick-start/#quick-start","text":"","title":"Quick Start"},{"location":"getting_started/quick-start/#selecting-a-target","text":"After you have successfully installed kubetap , find a Service you'd like to tap. In this example, we use ArgoCD as the target. $ kubectl get svc -n argocd NAME TYPE CLUSTER-IP EXTERNAL-IP PORT ( S ) AGE argocd-dex-server ClusterIP 10 .43.152.9 <none> 5556 /TCP,5557/TCP 5d20h argocd-metrics ClusterIP 10 .43.44.33 <none> 8082 /TCP 5d20h argocd-redis ClusterIP 10 .43.209.196 <none> 6379 /TCP 5d20h argocd-repo-server ClusterIP 10 .43.192.56 <none> 8081 /TCP,8084/TCP 5d20h argocd-server-metrics ClusterIP 10 .43.220.237 <none> 8083 /TCP 5d20h argocd-server ClusterIP 10 .43.118.109 <none> 80 /TCP,443/TCP 5d20h","title":"Selecting a target"},{"location":"getting_started/quick-start/#tapping-the-service","text":"The proxy container (MITMProxy by default) runs as a sidecar, keeping network traffic within the cluster and incurring a lessened performance penalty when proxying the traffic. For this example, we target the HTTPS argocd-server service: $ kubectl tap on -n argocd -p 443 --https argocd-server --port-forward Establishing port-forward tunnels to service... Port-Forwards: mitmproxy - http://127.0.0.1:2244 argocd-server - http://127.0.0.1:4000","title":"Tapping the service"},{"location":"getting_started/quick-start/#connecting-to-the-proxy","text":"As shown above, you can now navigate to http://127.0.0.1:2244 to access the proxy. Note that you can also use the --browser flag with tap on to automatically open the printed URLs in the default browser. --browser implies --port-forward . http://127.0.0.1:2244","title":"Connecting to the proxy"},{"location":"getting_started/quick-start/#listing-active-taps","text":"All active taps can be listed using the following command, which can be constrained to a specific namespace with -n : $ kubectl tap list Tapped Namespace/Service: argocd/argocd-server","title":"Listing active taps"},{"location":"getting_started/quick-start/#untapping-the-service","text":"Once we are finished, we can remove the proxy and revert our tap by turning it off: $ kubectl tap off -n argocd argocd-server Untapped Service \"argocd-server\"","title":"Untapping the service"},{"location":"getting_started/usage/","text":"Usage Kubetap's binary is kubectl-tap . This allows kubetap to be invoked as kubectl tap . Kubetap inherits many options from the kubectl command, including useful options such as: --context , --user , --as , etc. Tap On Deploy a proxy to tap the target Service, in the case of this example, the argocd-server Service's exposed port 443 which uses HTTPS. kubectl tap on -n argocd argocd-server -p443 --https Tap Off Remove the tap from the argocd-server Service. kubectl tap off -n argocd argocd-server Tap List The namespaces can be constrained with -n , but by default it lists taps in all namespaces: $ kubectl tap list Tapped Namespace/Service: argocd/argocd-server In a container It is possible to schedule kubetap as a Pod in Kubernetes using the grc.io/soluble-oss/kubectl-tap:latest container. When run in a cluster, kubetap will automatically detect and use ServiceAccount tokens that are mounted to the container's filesystem. Additionally, it is possible to run the containers from a developer laptop as follows: docker run -v \" ${ HOME } /.kube/:/.kube/:ro\" 'gcr.io/soluble-oss/kubectl-tap:latest' on -n mynamespace -p80 myservice docker run -v \" ${ HOME } /.kube/:.kube/:ro\" 'gcr.io/soluble-oss/kubectl-tap:latest' off -n mynamespace myservice Image variations Kubetap is built on alpine, and available at gcr.io/soluble-ass/kubectl-tap . Images are distributed under two major tags: Image and tag Description gcr.io/soluble-oss/kubectl-tap:latest Alpine build and scratch execution environment. Tiny container, no shell. gcr.io/soluble-oss/kubectl-tap:alpine Alpine build and execution environment. Useful for debugging, has a shell.","title":"Usage"},{"location":"getting_started/usage/#usage","text":"Kubetap's binary is kubectl-tap . This allows kubetap to be invoked as kubectl tap . Kubetap inherits many options from the kubectl command, including useful options such as: --context , --user , --as , etc.","title":"Usage"},{"location":"getting_started/usage/#tap-on","text":"Deploy a proxy to tap the target Service, in the case of this example, the argocd-server Service's exposed port 443 which uses HTTPS. kubectl tap on -n argocd argocd-server -p443 --https","title":"Tap On"},{"location":"getting_started/usage/#tap-off","text":"Remove the tap from the argocd-server Service. kubectl tap off -n argocd argocd-server","title":"Tap Off"},{"location":"getting_started/usage/#tap-list","text":"The namespaces can be constrained with -n , but by default it lists taps in all namespaces: $ kubectl tap list Tapped Namespace/Service: argocd/argocd-server","title":"Tap List"},{"location":"getting_started/usage/#in-a-container","text":"It is possible to schedule kubetap as a Pod in Kubernetes using the grc.io/soluble-oss/kubectl-tap:latest container. When run in a cluster, kubetap will automatically detect and use ServiceAccount tokens that are mounted to the container's filesystem. Additionally, it is possible to run the containers from a developer laptop as follows: docker run -v \" ${ HOME } /.kube/:/.kube/:ro\" 'gcr.io/soluble-oss/kubectl-tap:latest' on -n mynamespace -p80 myservice docker run -v \" ${ HOME } /.kube/:.kube/:ro\" 'gcr.io/soluble-oss/kubectl-tap:latest' off -n mynamespace myservice","title":"In a container"},{"location":"getting_started/usage/#image-variations","text":"Kubetap is built on alpine, and available at gcr.io/soluble-ass/kubectl-tap . Images are distributed under two major tags: Image and tag Description gcr.io/soluble-oss/kubectl-tap:latest Alpine build and scratch execution environment. Tiny container, no shell. gcr.io/soluble-oss/kubectl-tap:alpine Alpine build and execution environment. Useful for debugging, has a shell.","title":"Image variations"},{"location":"kubetap_development/","text":"Kubetap Development This section provides information about Kubetap development processes and how to contribute. Kubetap overview Kubtap is developed by Matt Hamilton at Soluble.ai as an Apache v2 Licensed open source project. Kubetap arose from a need to quickly and efficiently proxy Kubernetes Services without imposing a CNI mandate. Building kubetap requires the following dependencies: dependency purpose notes kubectl ... mandatory for integration tests docker Build containers not needed to build kubectl-tap binary go Build kubectl-tap minimum Go version 1.13 zsh Build scripts scripting is nicer than bash or sh Script-managed dependencies, installed using go get and ci.mod or ig-tests.mod : dependency purpose notes golangci-lint Linting ( ci.mod ) used as Go code linter gotestsum Testing ( ci.mod ) used to make test output prettier kind Testing ( ig-tests.mod ) required for integration tests helm Testing ( ig-tests.mod ) used to deploy test apps to kind cluster Hacking on Kubetap Assuming you have built kubetap from source , you're ready to hack on kubetap. $ cd ${ GOPATH } /src/github.com/soluble-ai/kubetap $ go generate . $ go build ./cmd/kubectl-tap","title":"Overview"},{"location":"kubetap_development/#kubetap-development","text":"This section provides information about Kubetap development processes and how to contribute.","title":"Kubetap Development"},{"location":"kubetap_development/#kubetap-overview","text":"Kubtap is developed by Matt Hamilton at Soluble.ai as an Apache v2 Licensed open source project. Kubetap arose from a need to quickly and efficiently proxy Kubernetes Services without imposing a CNI mandate. Building kubetap requires the following dependencies: dependency purpose notes kubectl ... mandatory for integration tests docker Build containers not needed to build kubectl-tap binary go Build kubectl-tap minimum Go version 1.13 zsh Build scripts scripting is nicer than bash or sh Script-managed dependencies, installed using go get and ci.mod or ig-tests.mod : dependency purpose notes golangci-lint Linting ( ci.mod ) used as Go code linter gotestsum Testing ( ci.mod ) used to make test output prettier kind Testing ( ig-tests.mod ) required for integration tests helm Testing ( ig-tests.mod ) used to deploy test apps to kind cluster","title":"Kubetap overview"},{"location":"kubetap_development/#hacking-on-kubetap","text":"Assuming you have built kubetap from source , you're ready to hack on kubetap. $ cd ${ GOPATH } /src/github.com/soluble-ai/kubetap $ go generate . $ go build ./cmd/kubectl-tap","title":"Hacking on Kubetap"},{"location":"kubetap_development/TODOs/","text":"TODOs Features Feature requests are recorded on GitHub and available here","title":"TODOs"},{"location":"kubetap_development/TODOs/#todos","text":"","title":"TODOs"},{"location":"kubetap_development/TODOs/#features","text":"Feature requests are recorded on GitHub and available here","title":"Features"},{"location":"kubetap_development/caveats/","text":"Caveats As with everything, there are some caveats and pitfalls. Kubetap Usage High-Volume Taps If the target Service has a high request to pod ratio, you may encounter memory issues, as mitmweb retains all requsets in memory. If you are in this situation but willing to sacrafice the realtime interactive interface, you can use the --comand-args flag to modify the sidecar command to use mitmdump. Or, you can use a custom image using the --image flag to provide your own custom tooling. Custom Images You can use a custom proxy image using the --image flag, but be warned that there are no compatibility guarantees at the present time. In the future, support for additional proxy types and configurations may be added. Until then, there is no official support for custom images. You're on your own. Kubernetes dashboard The kubernetes dashboard cannot be tapped by kubetap because the dashboard does not have a Pod for a sidecar to be injected into. >1 Replica If there are multiple replicas, the proxy sidecar will be deployed to all replicas. This behavior ensures that all Service traffic is collected, but never leaves the local Pod during the proxy. Connecting to (what the situation dictates being) the correct proxy is left to the operator, as it is not possible for Kubetap to know the circumstances of a given environment and desired proxy configuration. Ports 7777 and 2244 These are \"magic ports\" used by kubetap. The former is used as the proxy listener and the latter is the proxy web interface. If the target Pod container has already reserved these ports, kubetap will fail. We should eventually automate incrementing and fixing this, but for now kubetap cannot target ports 7777 or 2244. Security Restrictions If you use PSPs, the target Pod will need access to ConfigMap s and EmptyDir s. If the target Pod does not have access to these resources, kubetap will fail.","title":"Caveats"},{"location":"kubetap_development/caveats/#caveats","text":"As with everything, there are some caveats and pitfalls.","title":"Caveats"},{"location":"kubetap_development/caveats/#kubetap-usage","text":"","title":"Kubetap Usage"},{"location":"kubetap_development/caveats/#high-volume-taps","text":"If the target Service has a high request to pod ratio, you may encounter memory issues, as mitmweb retains all requsets in memory. If you are in this situation but willing to sacrafice the realtime interactive interface, you can use the --comand-args flag to modify the sidecar command to use mitmdump. Or, you can use a custom image using the --image flag to provide your own custom tooling.","title":"High-Volume Taps"},{"location":"kubetap_development/caveats/#custom-images","text":"You can use a custom proxy image using the --image flag, but be warned that there are no compatibility guarantees at the present time. In the future, support for additional proxy types and configurations may be added. Until then, there is no official support for custom images. You're on your own.","title":"Custom Images"},{"location":"kubetap_development/caveats/#kubernetes-dashboard","text":"The kubernetes dashboard cannot be tapped by kubetap because the dashboard does not have a Pod for a sidecar to be injected into.","title":"Kubernetes dashboard"},{"location":"kubetap_development/caveats/#1-replica","text":"If there are multiple replicas, the proxy sidecar will be deployed to all replicas. This behavior ensures that all Service traffic is collected, but never leaves the local Pod during the proxy. Connecting to (what the situation dictates being) the correct proxy is left to the operator, as it is not possible for Kubetap to know the circumstances of a given environment and desired proxy configuration.","title":"&gt;1 Replica"},{"location":"kubetap_development/caveats/#ports-7777-and-2244","text":"These are \"magic ports\" used by kubetap. The former is used as the proxy listener and the latter is the proxy web interface. If the target Pod container has already reserved these ports, kubetap will fail. We should eventually automate incrementing and fixing this, but for now kubetap cannot target ports 7777 or 2244.","title":"Ports 7777 and 2244"},{"location":"kubetap_development/caveats/#security-restrictions","text":"If you use PSPs, the target Pod will need access to ConfigMap s and EmptyDir s. If the target Pod does not have access to these resources, kubetap will fail.","title":"Security Restrictions"},{"location":"kubetap_development/contributing/","text":"Contributing DCO Contributions to kubetap require signing-off commits to accept the DCO . This is my commit message Signed-off-by: Random J Developer <random@developer.example.org> This is done by using the -s flag for git commit , as in: $ git commit -s -m 'This is my commit message' Git Philosophy The master branch should be safe to deploy at any time, with the understanding that while safe, it is less tested than a tagged release. All commits to the master branch should be cryptographically signed. All commits should be squashed with an appropriate commit message prior to merge. Merge commits are ugly and not necessary. git config --global pull.rebase = true","title":"Contributing"},{"location":"kubetap_development/contributing/#contributing","text":"","title":"Contributing"},{"location":"kubetap_development/contributing/#dco","text":"Contributions to kubetap require signing-off commits to accept the DCO . This is my commit message Signed-off-by: Random J Developer <random@developer.example.org> This is done by using the -s flag for git commit , as in: $ git commit -s -m 'This is my commit message'","title":"DCO"},{"location":"kubetap_development/contributing/#git-philosophy","text":"The master branch should be safe to deploy at any time, with the understanding that while safe, it is less tested than a tagged release. All commits to the master branch should be cryptographically signed. All commits should be squashed with an appropriate commit message prior to merge. Merge commits are ugly and not necessary. git config --global pull.rebase = true","title":"Git Philosophy"},{"location":"kubetap_development/scripts/","text":"Scripts Scripts to manage the project. They can also be invoked from the Makefile at the project's root. All scripts require Zsh. Variable modifiers are too useful to consciously choose to use /bin/sh like a caveman. A recent (enough) version of zsh installed in Macs by default, and every distro has a zsh package. Script Purpose build.zsh meta build script, excluding container builds and integration tests build-mitmproxy.zsh builds the mitmproxy container build-kubetap.zsh builds the kubectl-tap binary docs-build.zsh builds the static files for gh-pages docs-serve.zsh interactive local docs served by mkdocs images.zsh strip metadata and perform lossless compression test.zsh unit tests ig-test.zsh integration tests _pre.zsh run by other scripts - handles output formatting and PWD storage _post.zsh run by other scripts - restores PWD state from pre.zsh","title":"Scripts"},{"location":"kubetap_development/scripts/#scripts","text":"Scripts to manage the project. They can also be invoked from the Makefile at the project's root. All scripts require Zsh. Variable modifiers are too useful to consciously choose to use /bin/sh like a caveman. A recent (enough) version of zsh installed in Macs by default, and every distro has a zsh package. Script Purpose build.zsh meta build script, excluding container builds and integration tests build-mitmproxy.zsh builds the mitmproxy container build-kubetap.zsh builds the kubectl-tap binary docs-build.zsh builds the static files for gh-pages docs-serve.zsh interactive local docs served by mkdocs images.zsh strip metadata and perform lossless compression test.zsh unit tests ig-test.zsh integration tests _pre.zsh run by other scripts - handles output formatting and PWD storage _post.zsh run by other scripts - restores PWD state from pre.zsh","title":"Scripts"}]}